import { Component, Injectable } from '@angular/core';
import { BehaviorSubject, Observable, ReplaySubject, Subject } from 'rxjs';
import { Group, NewGroup, GroupForm, Tag, Project } from '../models/models';
import { map, first } from 'rxjs/operators';
import { GroupsService } from './groups.service';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { ProjectsService } from './projects.service';
import { GeoDataService } from './geo-data.service';
import { prepareSyntheticListenerFunctionName } from '@angular/compiler/src/render3/util';
import { fadeInItems } from '@angular/material';
import { Feature, FeatureCollection } from 'geojson';

@Injectable({
  providedIn: 'root',
})
export class FormsService {
  private _forms: BehaviorSubject<Group[]> = new BehaviorSubject([]);
  public forms: Observable<Group[]> = this._forms.asObservable();

  private _activeFormList: BehaviorSubject<any[]> = new BehaviorSubject([]);
  public activeFormList: Observable<any[]> =
    this._activeFormList.asObservable();

  private _formGroup: BehaviorSubject<FormGroup> =
    new BehaviorSubject<FormGroup>(null);
  public formGroup: Observable<FormGroup> = this._formGroup.asObservable();

  private activeGroup;
  private groups: Map<string, NewGroup>;
  private groupsFeatures: Map<string, any>;
  private featureList: Array<any> = [];
  features: FeatureCollection;
  private selectedProject;
  private selectedFeatureID;
  private selectedFeature;

  constructor(
    private groupsService: GroupsService,
    private projectsService: ProjectsService,
    private geoDataService: GeoDataService
  ) {
    this.geoDataService.activeGroup.subscribe((next) => {
      this.activeGroup = next;
    });

    this.geoDataService.groups.subscribe((next) => {
      this.groups = next;
    });

    this.geoDataService.groupsFeatures.subscribe((next) => {
      this.groupsFeatures = next;
    });

    this.projectsService.activeProject.subscribe((next) => {
      this.selectedProject = next;
    });

    this.geoDataService.activeFeature.subscribe((next) => {
      this.selectedFeature = next;
    });
    this.geoDataService.features.subscribe((fc: FeatureCollection) => {
      this.features = fc;

      if (this.features != undefined) {
        this.featureList = this.features.features;
      }
    });
  }

  checkDefault(selectedColor: string) {
    if (selectedColor === 'default') {
      try {
        selectedColor = this.selectedFeature.styles.color;
      } catch (error) {
        selectedColor = '#00C8FF';
      }
    }
    return selectedColor;
  }

  //Inputs:
  //color:string A 7 digit hexadecimal string (#RRGGBB) passed in from a color tag
  //This method accesses group services to retrive the current group's icon as well
  // REDO: because it doesn't utilize hazmapper's styles properly
  saveStyles(
    projectId: number,
    selectedColor: string,
    groupName: string,
    feature: Feature
  ) {
    const group = this.groups.get(groupName);
    group.color = this.checkDefault(selectedColor);

    const style = {
      faIcon: group.icon,
      color: group.color,
    };

    this.geoDataService.updateGroupFeatures(projectId, [feature], group);
    this.geoDataService.updateFeatureStyle(projectId, feature.id, style);
  }

  addGroup(groupName: string) {
    let groupObject = new Group();
    groupObject.formList = [];

    groupObject.groupName = groupName;

    this.forms.pipe(first()).subscribe((current) => {
      current.push(groupObject);
      this._forms.next(current);
    });
  }

  userTag: tags = {
    type: 'text',
    groupName: 'car',
    label: 'Title',
    options: [],
    feature: '',
    extra: [],
  };
  tagData = [];
  checkedOptions = [];
  chosenTag = [{ option: '', id: 0 }, '', '']; //chosen option of both Radio Buttons and Color tags. Radio info is stored at [0], Color at [1]
  notebook = []; //Var for storing note tags

  optData = [];
  deleteOpt(gName: string, opt: object, tag: tags): void {
    const index = this.optData.findIndex(
      (item) => item.groupName === gName && item.label === tag.label
    );
    if (index > -1) {
      const ind = this.optData[index].options.findIndex((item) => item === opt);
      if (ind > -1) {
        this.optData[index].options.splice(ind, 1);
      }
    }
  }

  updateTagValue(
    activeProject: Project,
    feature: Feature,
    form: GroupForm,
    tagValue: any
  ) {
    let tagProp = feature.properties.tags ? feature.properties.tags : [];
    tagProp = tagProp.filter((tag: Tag) => form.id !== tag.id);

    const tag = {
      id: form.id,
      value: tagValue,
    };

    feature.properties.tags = [...tagProp, tag];
    console.log(feature.properties.tags);
    //
    this.geoDataService.updateFeatureProperty(
      activeProject.id,
      feature.id,
      feature.properties
    );
  }

  updateTagValues(
    activeProject: Project,
    feature: Feature,
    formList: GroupForm[],
    newValues: any[]
  ) {
    feature.properties.tags = newValues;
    this.geoDataService.updateFeatureProperty(
      activeProject.id,
      feature.id,
      feature.properties
    );
  }

  getTagValue(feature: Feature, form: GroupForm): any {
    if (feature.properties.tags) {
      const tagValueObj = feature.properties.tags.find(
        (featTag: any) => featTag.id && featTag.id === form.id
      );

      if (tagValueObj) {
        return tagValueObj.value;
      }
    }
    if (form.type === 'checkbox') {
      return [];
    } else {
      return '';
    }
  }

  //Functions for radio buttons componentId=0 is for the radio component, componentId=1 is for color
  // updateSelectedRadio(
  //   selection: string,
  //   componentId: number,
  //   featureId: number,
  //   group: string,
  //   label: string
  // ) {
  //   const groupObj = this.groups.get(group);
  //   // this.tempgroup
  //   const groupFeatures = this.groupsFeatures.get(group);
  //   const icon = groupObj.icon;
  //   const tempGroup = [{ ...groupObj }];
  //   // i.e. feature.properties
  //   const payload = {
  //     group: tempGroup,
  //     style: {
  //       faIcon: icon,
  //       color: this.checkDefault('default'),
  //     },
  //     tag: [],
  //   };

  //   groupFeatures.forEach((feat: Feature) => {
  //     // NOTE: This is to get only the ones that exist and update the current group, which is unnecessary...
  //     if (feat.properties.tag != undefined || feat.properties.tag != []) {
  //       feat.properties.group.forEach((group) => {
  //         if (group.name != this.activeGroup) {
  //           let tempGroup = {
  //             name: group.name,
  //             color: group.color,
  //             icon: group.icon,
  //           };
  //           payload.group.push(tempGroup);
  //         }
  //       });
  //     }

  //     // code from here is a mess
  //     //Which means my problem is probably somewhere in here
  //     if (feat.properties.tag != undefined) {
  //       this.tagData.forEach((tag) => {
  //         if (tag.feature === featureId && tag.groupName === group) {
  //           const index = tag.extra.findIndex(
  //             (item) =>
  //               item['id'] === featureId &&
  //               item['compId'] === componentId &&
  //               item['groupName'] === group &&
  //               item['label'] === label
  //           );

  //           if (index > -1) {
  //             tag.extra[index]['option'] = selection;
  //           } else {
  //             let rOption = {
  //               option: selection,
  //               id: featureId,
  //               compId: componentId,
  //               groupName: group,
  //               label: label,
  //             };
  //             tag.extra.push(rOption);
  //           }
  //         }
  //         payload.tag.push(tag);
  //       });
  //     }

  //     this.geoDataService.updateFeatureProperty(
  //       this.selectedProject.id,
  //       Number(feat.id),
  //       payload
  //     );
  //     // Clear out the tag section
  //     payload.tag = [];
  //   });
  // }

  //TODO: Rename this function, it's called getSelectedRadio, but it's used as the getter for every tag type
  // getSelectedRadio(): any[] {
  //   this.newOpt = [];
  //   for (let feat of this.featureList) {
  //     if (feat.properties.tag != undefined) {
  //       feat.properties.tag.forEach((tag) => {
  //         this.newOpt.push(tag.extra);
  //       });
  //     }
  //   }
  //   return this.newOpt;
  // }

  //Notes tag functions
  // updateNotes(
  //   change: string,
  //   componentID: number,
  //   feature: number,
  //   group: string,
  //   label: string
  // ) {
  //   let icon: string;
  //   let payload;
  //   this.groupList.forEach((tGroup) => {
  //     if (tGroup.name == group) {
  //       console.log(group);
  //       this.tempGroup = tGroup.features;
  //       icon = tGroup.icon;

  //       //Creates a temporary group with a copy of the current groups info
  //       let tempGroup = [
  //         {
  //           name: tGroup.name,
  //           color: tGroup.color,
  //           icon: tGroup.icon,
  //         },
  //       ];

  //       //And adds the temp group to a payload along with the necessary style infromation
  //       payload = {
  //         group: tempGroup,
  //         style: {
  //           faIcon: icon,
  //           color: this.checkDefault('default'),
  //         },
  //         tag: [],
  //       };
  //     }
  //   });

  //   for (let feat of this.tempGroup) {
  //     if (feat.properties.tag != undefined || feat.properties.tag != []) {
  //       feat.properties.group.forEach((group) => {
  //         if (group.name != this.activeGroup) {
  //           let tempGroup = {
  //             name: group.name,
  //             color: group.color,
  //             icon: group.icon,
  //           };
  //           payload.group.push(tempGroup);
  //         }
  //       });
  //     }

  //     // code from here is a mess
  //     if (feat.properties.tag != undefined) {
  //       this.tagData.forEach((tag) => {
  //         if (
  //           tag.feature === feature &&
  //           tag.groupName === group &&
  //           tag.type === 'text'
  //         ) {
  //           const index = tag.extra.findIndex(
  //             (item) =>
  //               item['id'] === feature &&
  //               item['compID'] === componentID &&
  //               item['groupName'] === group &&
  //               item['label'] === label
  //           );
  //           // const index = tag.extra.findIndex(item => item.label === opt['label'] && item.id === id && item.group === group)

  //           if (index > -1) {
  //             // console.log(tag.extra)
  //             // console.log(tag.extra[index])
  //             tag.extra[index]['option'] = change;
  //           } else {
  //             let rOption = {
  //               option: change,
  //               id: feature,
  //               groupName: group,
  //               compID: componentID,
  //               label: label,
  //             };
  //             // console.log(rOption)
  //             tag.extra.push(rOption);
  //           }
  //         }
  //         if (tag.feature == feature) {
  //           payload.tag.push(tag);
  //         }
  //       });
  //     }

  //     // console.log(typeof(payload.tag))
  //     // this.geoDataService.updateFeatureProperty(
  //     //   this.selectedProject.id,
  //     //   Number(feat.id),
  //     //   payload
  //     // );

  //     // Clear out the tag section
  //     payload.tag = [];
  //   }
  //   // if (index > -1) {
  //   // 	// console.log("IT WORKED")
  //   // 	this.notebook[index]['option'] = change
  //   // }
  //   // else {
  //   // 	let rOption = {option: change, id: feature, groupName: group}
  //   // 	this.notebook.push(rOption);
  //   // 	// console.log(this.tagData)
  //   // }
  // }

  // getNotes(): any[] {
  //   return this.notebook;
  // }
}

//Todo: put this in models so we can reference it like we do the Features type
export interface tags {
  type: string;
  groupName: string;
  label: string;
  options: Array<Group>;
  feature: string | number;
  extra: Array<Group>;
  id?: string;
}
